## 异常
异步异常：中断，
同步异常：陷阱，故障，终止
### Linux/x86-64 系统中的异常
有高达 256 种不同的
异常类型0~31的号码对应的是由 Intel 架构师定义的异常，因此对任何 x86-64 系统都
是一样的。32~255 的号码对应的是操作系统定义的中断和陷阱。
- 一般保护故障 Segmentation fault
-  缺页 
- 机器检查。
### Linux/86-64 系统调用
C 程序用 syscall 函数可以直接调用任何系统调用。然而，实际中几乎没必要这么做。对 于大多数系统调用，标准 C 库提供了一组方便的包装函数。这些包装函数将参数打包到一起, 以适当的系统调用指令陷人内核，然后将系统调用的返回状态传递回调用程序。在本书中，我 们将系统调用和与它们相关联的包装函数都称为系统级函数，这两个术语可以互换地使用。
## 进程
### 逻辑控制流
进程是轮流使用处理器的。每个进程执行它的流的一部分，然 后被抢占（preempted)(暂时挂起）， 然后轮到其他进程。对于一个运行在这些进程之一的上下文中的程序，它看上去就像是在独占地使用处理器。
### 并发流
多个流并发地执行的一般现象被称为并发（concurrency)。一个进程和其他进程轮流运 行的概念称为多任务（multitasking)。一个进程执行它的控制流的一部分的每一时间段叫 做时间片（time S.lics)因此，多任务也叫做时间分片（time slicing)例如，图 8-12 中，进 程 A 的流由两个时间片组成。 注意，并发流的思想与流运行的处理器核数或者计算机数无关。如果两个流在时间上 重叠，那么它们就是并发的，即使它们是运行在同一个处理器上。不过，有时我们会发现 确认并行流是很有帮助的，它是并发流的一个真子集。如果两个流并发地运行在不同的处 理器核或者计算机上，那么我们称它们为并行流（parallel flow), 它们并行地运行（running _in parallel)，且并行地执行（parallel execution)
### 私有地址空间
### 用户模式与内核模式
### 上下文切换
对一个进程维护上下文，在发生上下文切换时调用其上下文，实现进程的正常处理

## 系统调用错误处理

## 一些前置知识
- 当 Unix 系统级函数遇到错误时，它们通常会返回一1，并设置全局整数变量 来表示什么出错了。
```c
if ((pid = fork())< 0){
//内部是一些对于fork()返回错误值的操作
}
```
- strerror 函数返回一个文本串，描述了和某个 errno 值相关联的错误。
下面是 fork 函数的错误处理包装函数：
``` C
pid_t Fork(void)
{
	pid_t pid;

	if((pid = fork()) < 0)
		unix_error("Fork error");
		return pid;
}
//包装后
pid_t pid = Fork();


```
我们将在本书剩余的部分中都使用错误处理包装函数。它们能够保持代码示例简洁，而 又不会给你错误的假象，认为允许忽略错误检査。注意，当在本书中谈到系统级函数时，我 们总是用它们的小写字母的基本名字来引用它们，而不是用它们大写的包装函数名来引用。
关于 Unix 错误处理以及本书中使用的错误处理包装函数的讨论，请参见附录 A,包装函数定义在一个叫做 csapp.c 的文件中，它们的原型定义在一个叫做 csapp.h 的头文 件中；可以从 CS:APP 网站上在线地得到这些代码。

## 进程控制

[[2024-03-18]]

#### 获取进程ID
每个进程都有一个唯一的正数(非零)进程 ID(PID)。getpid 函数返回调用进程的 PID， getppid函数返回它的父进程的 PID(创建调用进程的进程)。getpid 和 getppid 函数返回一个类型为 pid_t 的整数值，在 Linux 系统上它在 types.h 中被定义为 int。

#### 创建和终止进程
程序有三种状态：运行，停止，终止
进程会因为三种原因终止：1)收到一个信号，该信号的 默认行为是终止进程，2)从主程序返回，3)调用 exit 函数。
```c
#include <stdlib.h>
void exit(int status);
//该函数不返回。
```
exit 函数以 status 退出状态来终止进程（另一种设置退出状态的方法是从主程序中 返回一个整数值）。 父进程通过调用 fork 函数创建一个新的运行的子进程。
```c
#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);
//返回：子进程返回 0，父进程返回子进程的 PID, 如果出错，则为 -1。
```
##### 父进程与子进程

新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的(但是独立的)一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用 fork 时，子进程可以读写父 进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的 PID.

##### fork函数的性质
[[2024-03-20]]
fork 函数是有趣的（也常常令人迷惑）， 因为它只被调用一次，却会返回两次：一次是在调用进程（父进程）中，一次是在新创建的子进程中。在父进程中，fork 返回子进程的 PID。在子进程中，fork 返回 0。因为子进程的 PID 总是为非零，==返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。==
```c
#include<sys/types.h>
#include<unistd.h>
pid_t fork(void);

```
fork()的返回：对子进程返回 0，对父进程返回子进程的 PID, 如果出错，则返回 -1。
父进程与子进程的一些特性：
- 并发执行。父进程和子进程是并发运行的独立进程。内核能够以任意方式交替执行 它们的逻辑控制流中的指令。
- 相同但是独立的地址空间。如果能够在 fork 函数在父进程和子进程中返回后立即 暂停这两个进程，我们会看到两个进程的地址空间都是相同的。每个进程有相同的 用户栈、相同的本地变量值、相同的堆、相同的全局变量值，以及相同的代码。
- 共享文件。当运行这个示例程序时，我们注意到父进程和子进程都把它们的输出显 示在屏幕上。原因是子进程继承了父进程所有的打开文件。当父进程调用 fork 时， stdout 文件是打开的，并指向屏幕。子进程继承了这个文件，因此它的输出也是 指向屏幕的。
可以通过画进程图来理解fork()函数的操作过程
[[2024-03-19]]
###### 回收子进程
进程终止后，保持在一种已经终止的状态，直到被它的父进程回收
终止而未被回收的进程被称为僵死进程
如果一个父进程终止了，内核会安排 init 进程成为它的孤儿进程的养父。 进程 的 PID 为 1，是在系统启动时由内核创建的，它不会终止，是所有进程的祖先。如果父进 程没有回收它的僵死子进程就终止了，那么内核会安排 init 进程去回收它们。

一个进程可以通过调用waitpid()函数来等待它的子进程终止或停止
```c
#include<sys/types.h>
#include<sys/wait.h>
pid_t waitpid(pid_t pid, int *statusp, int options);
```
返回：如果成功，则为子进程的 PID, 如果 WNOHANG,则为 0，如果其他错误，则为 -1。


一些Unix系统函数相关常量

wait函数
是waitpid函数的简单版本

##### 让进程休眠
sleep()
```c
#include<unistd.h>
unsigned int sleep(unsigned int secs);

```
返回：还要休眠的秒数。
//这里有一个问题，这个函数会不停地返回一个倒计时一样的时间知道变为0吗？
如果请求的时间量已经到了，sleep 返回 0, 否则返回还剩下的要休眠的秒数。
让进程挂起一段指定的时间
pause()
```c
#include<unistd.h>
int pause(void);
```
该函数让调用函数休眠，直到该进程收到一个信号

##### 加载并运行程序
execve()
```c
#include<unistd.h>
int execve(const char *filename, const char *argv[],const char *envp[]);
```
如果成功，则不返回，如果错误，则返回一1。
execve 函数加载并运行可执行目标文件 filename, 且带参数列表 argv 和环境变量列表 envp.只有当出现错误时，例如找不到 filename,才会返回到调用程序。

在当前进程的上下文中加载并运行一个新程序

程序与进程
https://blog.csdn.net/dawuga/article/details/104142212

##### 利用fork()和execve()运行程序
shell中使用了大量的fork和execve
###### eval() 函数
比较复杂，这里就暂时不展开


##### 信号
一种更高层的软件形式的异常，称为Unix信号，它允许进程中断其他进程
最常见的:SIGSEGV
SIGINT
SIGKILL

[[2024-03-20]]
信号的一些背景知识
发送信号
内核发送信号给目的进程
进程调用了kill(),要求内核发送信号给目的进程
一个进程可以发送信号给它自己
接收信号
当目的进程被内核强迫以某种方式对信号的发送做出反应时，目的进程就接收了信号。
#### 发送信号
Unix系统的发送信号机制，基于进程组的概念
##### 进程组
每个进程都只属于一个进程组，由一个进程组ID标识

getpgrp()
返回当前进程组的ID

默认情况下
一个子进程和他的父进程同属于一个进程组。一个进程可以通过
setpgid()
来改变自己或者其他进程的进程组ID
#### 用/bin/kill程序发送信号
```sh
/bin/kill -9 -15213
```
此程序可以向另外的进程发送任意的信号
发送信号9（SIGKILL）给进程15213。一个为负的PID会导致信号被发送到该进程所属进程组中的所有进程
一些shell有自己内置的kill命令，这里使用了完整路径/bin/kill
#### 从键盘发送信号
signal()

#### 接收信号
每一个信号类型都有一个预定义的默认行为 
进程终止
进程终止并转储存储器 （dump core）
进程停止直到被SIGCONT信号重启
进程忽略该信号
进程可以通过使用signal()
函数修改和信号相关联的默认行为，例外是SIGKILL与SIGSTOP的默认行为是不能被修改的

[[2024-03-21]]
[[2024-03-22]]
#### 信号处理问题
当一个程序要捕获多个信号时，存在一些细微的问题
##### 待处理信号被阻塞
##### 待处理信号不会排队等待
##### 系统调用可以被中断


这部分底层的关于信号处理与并发控制，有点过于底层了，建议是了解一下，除非是有研究底层的需求，否则没有必要过于深入
