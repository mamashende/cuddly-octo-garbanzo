## 理解补码的最高位
负权重：  
最高有效位 也称为符号位，它的“权重”为 2^(n-1)，是无符号表示中权重的负数。符号位被设置为 1 时，表示值为负，而当设置为 0 时，值为非负。//n-1位，从0开始计数  
![[Pasted image 20240304220534.png]]  
注意：图片里的整数指的是无符号整数
## 补码，反码与原码的转换问题
原码到补码的简单口诀：最高位不变，其余位按位取反，最后+1
对一个补码求补码等于原码，但是原码‘-0’除外

![[mmexportc839d0b840c9c9c19d5c9068cc296e6f_1709562.jpeg]]
注意这里的原码中的‘-0’，他的补码被定义为‘-128’，无符号数为‘128’，这是不能通过简单按位取反+1得到的
强行按位取反+1，会多一位来到9位，得到的是无符号的‘256’，若舍去最高位，则得到的是‘0’
从这种角度看原码到补码的映射，会发现‘-0’与‘+0’被映射到了同一值，即为补码的‘0’

//还有就是从时钟的角度，从同余运算的角度去理解补码

#### 变补：
已知[X]补，求[-X]补
[X]补的代码连同符号位一起变反，末位再加1， 即得到[-X]补
### 有关溢出
### 对于二进制定点小数
原码中，没有明确小数的符号位与最大长度，因此表示负数时用-1.001011即可，正的二进制小数也同理，对于补码，正数不变，负数等于2减去原码的绝对值
## 浮点数的表示方法
### IEEE754
### 理论浮点数模型
![[Pasted image 20240305232138.png]]

![[Pasted image 20240305232225.png]]
若浮点数用补码表示，则尾数规格化的的要求是使尾数的绝对值满足条件  
$$ -1\le M < -1/2  或  1/2\le M< 1$$
此时满足规格化尾数的符号位与最高有效位刚好相反。
对于为什么1/2处的取舍问题，以及IEEE 754的非规范浮点数部分，可以深入了解一下

## 定点数的四则运算
### 加法运算
使用最简单的加法器进行补码加法
### 减法运算
使用求变补的方式转换为加法运算

### 乘法运算
#### 原码一位乘法运算
一位代表一次只进行一步的乘法
乘一位，累加，然后累加和右移一位，
最后处理符号位，简单的负负得正规则即可
#### 补码一位乘比较法
Booth算法
运算时采用双符号位，

#### 两位乘法运算
一次进行两位同时运算的乘法

2024-03-18
[[2024-03-18]]

## 除法运算
##### 原码不恢复余数法
1.取绝对值相除，符号位单独处理
2.
##### 补码不恢复余数法
首先被除数减除数，判断余数正负，
被除数与除数同号商为正，异号商为负
余数与除数同号商1，异号商0，然后
然后分别进行左移再加或减除数（同号减，异号加）
接下来继续左移加减除数的循环

除去第一步相减判断商符正负，统一使用左移再加减除数的话，得到的商不一定是正确的，需要进行商符的校正。
## 浮点数四则运算
注意，根据IEEE754,这里使用的是原码，且符号位特殊处理放在最前面

### 加减运算
先对阶，小阶向大阶对齐，小阶数向右移，对齐之后可能有少量精度损失，
然后加减运算
最后进行左规格化或者右规格化

### 乘除运算
#### 乘法
阶码相加还要再减127修正，否则阶码会溢出。
剩下的是定点小数乘法（原码）
最后规格化

#### 除法
阶码相减还要加127修正，否则阶码大小不对
剩下的是定点小数除法（原码）
最后规格化

## 常用的数据校验方法
### 奇偶校验
奇校验 加入校验位后，使信息串中1有奇数个
偶校验 加入校验位后，信息串中1有偶数个

### 海明校验
分组奇偶校验方法

### CRC循环冗余校验

模2运算
加减即为异或运算
乘法 不考虑进位
模2除
[[2024-03-19]]
问题:生成多项式是怎么定义的
生成多项式是事先约定好的，比如1011(B) 叫做 (7,4)码，即n=7,k=4
编码方法:
将待编码的k位串左移r位，然后模2除以生成多项式，将得到的余数加入左移的空位中去，
检验，将收到的串模2除以约定好的生成多项式，余数的值即代表出错的位，若无错，则余数为0