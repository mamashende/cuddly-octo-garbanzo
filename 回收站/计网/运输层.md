## 进程之间的通信
[[2024-03-21]]
### 端口
这里指的是软件端口
#### 服务端使用的端口号
##### 熟知端口
0～1023
1024～49151

##### 客户端的短暂端口号
进程可以短暂使用的端口号

多个应用进程同时分别与其他进程通信
运输层的复用和分用功能
TCP/UDP
运输层向高层应用屏蔽了下层的细节
[[2024-03-22]]

#### TCP:面向连接的可靠通信
特点：
面向连接
只能点对点通信
提供可靠交付
提供全双工通信
面向字节流传输，保持字节流一致即可123 45 跟12 345是等价的
数据传输做到不重复，不丢失，不失序
先建立连接，再进行通信，同时可以选择通信完成后断开或者保持一定的连接时间（此时无论有无数据报传输都保持连接）
发送缓存与接收缓存
TCP连接的端点是socket
形式    IP:Port

#### TCP连接建立过程

### 可靠传输的工作原理
##### 停止等待协议：收到接收方确认后再进行下一分组转发
这种情况下支持全双工通信
##### 计时器
对每个转发分组设置一个计时器
计时器时间内没有收到接收方回复，出现差错时，超时重传
接收方确实没有收到：
直接重传
确认丢失：接收方收到数据报后，回复的确认信息丢失了，会导致发送方重传，收到数据报后，重新向发送方发送确认


确认迟到：接收方确认信息因为网络问题迟到，

这两种情况都会导致发送方重传，接收方重复发送确认信息

#### 信道利用率
信道利用率的计算
为了提高传输效率，使用流水线传输
#### TCP数据报的格式
#### 连续ARQ协议
滑动窗口协议
发送方：收到确认后窗口向前滑动一位，并继续发送
接收方：累计确认方式
回退N
数据报12345中，3无法被接受到时，需要回退到3重传345这几个数据报
回退次数过多时，效率较低
[[2024-03-28]]
窗口的大小可随网络质量变化而变化，
网络质量变差，则窗口尾部向前滑动前部不动（不再发送）
网络质量变好，发送方可以很快把窗口扩大

发送缓存：已发送但是未被对方确认接收的数据
接收缓存：收到但是暂时未被应用接收的数据，或者是不按序到达的数据

发送窗口和接收窗口不一定一样大

接收方可以在合适的时间发送确认，也可以选择等待其他数据报，进行累计确认

##### 超时重传的时间选择
自适应算法
记录每一个报文的往返时间，计算RTTs 一般取α=0.125
得到平滑往返时间，从而作为超时重传的参考
同样需要计算的还有
RTTd
RTO（超时重传时间）

###### Karn算法
修正Karn算法

###### 选择确认SACK
接收方确认收到的数据块，同时返回未收到数据块标记

##### TCP流量控制
###### 通过滑动窗口实现流量控制
###### TCP的传输效率
三种机制，按

##### TCP拥塞控制
一旦出现数据报超时，就判定为发生了拥塞
###### 慢开始算法
###### 拥塞避免算法
###### 快重传和快恢复


##### 5.8.3主动队列管理AQM
尾部丢弃策略
尾部丢弃引发全局同步，全网的通信量都下降
随机早期检测RED，随机丢弃一部分数据报



#### 5.9TCP的运输连接管理
客户端和服务端
###### TCP连接的建立 三报文握手建立连接

###### TCP连接释放 



#### UDP:无连接的不可靠通信
主要特点：
无连接
面向报文
尽最大努力交付
没有拥塞控制
支持一对一，一对多，多对多交互通信
数据报首部开销很小，只有8字节

（发出去就不管了，那边的端口收到就收到了，收不到就算了）通常用于低延迟的语音/视频通信，稍微丟点包没关系

支持数据报的复用和分用
以及差错检测功能（这是保证数据完整性的检验，与稳定连接无关）
应用程序应该选择合适大小的报文，减少IP层的传输分片与低效率传输