### 3.1 任务（一）：在Linux 0.11应用程序中调用fork函数创建子进程

#### 调用fork函数创建子进程

在vi中编程并实现main.c
![[Pasted image 20241112192658.png]]

运行得到输出结果如下：
![[Pasted image 20241112192812.png]]
使用命令gcc main.c -o app生成可执行文件app。 4. 执行 chmod +x app命令为app文件添加可执行权限。 5. 执行sync命令，将文件保存到硬盘。 6. 使用命令./app运行可执行文件app，分析运行结果。

系统调用函数fork在执行时，会在进程表中创建一个与调用此函数的进程（父进程）几乎完全一样 的新的进程表项（子进程），子进程与父进程执行同样的代码，但子进程拥有自己的数据空间和环境参数。 在fork函数的返回位置处，父进程将恢复执行，而子进程也从相同的位置开始执行。在父进程中，fork 返回的值是子进程的进程标识号PID，而在子进程中fork函数返回的值是0（这正是fork的神奇之处， 调用一次，返回两次）


修改main.c
![[Pasted image 20241112193127.png]]

按照下面的步骤继续使用vi编辑器修改main.c文件： 1. 在printf(“PID:%d parent process continue\n”, getpid());语句前面添加一行语句： wait(NULL); 2. 重新编译、运行应用程序app，观察运行结果与之前有何不同。

运行结果如下：
![[Pasted image 20241112193234.png]]
由于
wait(NULL)的存在，在父进程start后，父进程创建子进程，然后父进程会等待，直到子进程结束，才会继续执行

#### 查看父进程与子进程的运行轨迹

断点调试
![[Pasted image 20241112195930.png]]
![[Pasted image 20241112195825.png]]

此时由于图中pid最大显示到6，所以无法看到子进程的情况（pid = 7）
但是的确可以观察到父进程(pid = 6)被阻塞的情况

如下图，已知app的大小是24900byte
![[Pasted image 20241112200345.png]]




条件断点调试

1. 在“WATCH”窗口添加last_pid和current->pid，查看它们的值。全局变量last_pid（在文件 kernel/fork.c 的第 30 行定义）记录了最新的进程号。current->pid的值是当前正在运行的进 程的进程号，也就是app应用程序的进程号。

![[Pasted image 20241112201253.png]]
2. 在“WATCH”窗 口 添加全局变量current并展开它的值，可以查看当前进程的信息。其中，“state=0” 表示当前进程（即使用可执行文件app创建的进程）正处于运行态；“counter=13”表示其剩余 时间片的大小；“priority=15”表示其优先级；“father=4”表示其父进程的进程号。如图5-1 所示。
![[Pasted image 20241112201356.png]]

3. 在“WATCH”窗口添加全局变量task并展开它的值，可以查看进程表中的所有进程的信息，如图 5-2 所示。其中，下标为4的那一项存储的地址，与图5-1中current指针所指向的地址是一致 的。也就是说，app应用程序进程和其它进程一样，都在task中进行了管理，但是由于该进程现 在正在运行，所以让current指向了它的进程控制块。注意，task中的元素是进程控制块的指针， 所以在每一个元素的右侧显示了它所指向的地址，同样适用于上面的注意事项。
![[Pasted image 20241112201530.png]]

4. 在VSCode的“View”菜单中选择“Command Palette...”，会 在 VSCode的顶部中间位置显示命 令面板，输入“Lab: New Visualizer View”命令后，VSCode 会在其右侧弹出一个窗口让读者查 看可视化视图。在右侧可视化视图顶部的编辑框中输入命令“#task”后按回车，就可以查看进 程列表了，如图5-3所示。其中背景色为绿色并且使用current游标指向的进程是当前进程，其 state 字段的值为0表示当前进程（即使用可执行文件app创建的进程）正处于运行态；counter 的值为11表示其剩余时间片的大小；priority的值为15表示其优先级；father的值为4表示 其父进程的进程号。读者也可以从图中直观的掌握其他进程的重要信息。
![[Pasted image 20241112201738.png]]

5. 按F10单步调试至第119行，再按F11进入fork系统调用的内核函数，可以看到其内核函数仍 然是一个汇编函数。
![[Pasted image 20241112201900.png]]
![[Pasted image 20241112201942.png]]

6. 按F10单步调试至第272行。此时，第271行的find_empty_process函数（在文件kernel/fork.c 的第175行定义）已经执行完毕，此函数为新进程取得了一个不重复的进程号，并在task数组 中找到了一个未被使用的任务数组项，并返回其索引(在EAX寄存器中返回)。查看“WATCH”窗 口，可看到last_pid的值已经发生了变化，该值后面会作为新建的子进程的进程号。


7. 按F10单步调试至第279行，然后按F11进入copy_process函数。读者可以注意到，在第278 行将EAX寄存器的值作为最后一个参数压入栈，根据C语言的函数调用约定，这也就意味着 copy_process 函数的第一个参数nr为子进程在任务数组task中的下标。


继续调试_copy_process_函数


2. 按F10单步执行第98行的代码，将鼠标移动到第98行代码处的变量p上，可以看到此时p指针 的值就是新分配的物理页的基址。

![[Pasted image 20241112202354.png]]
3. 按F10单步执行直到黄色箭头指向第103行。第101行将新创建的子进程控制块的指针放入了任 务数组中，数组索引由第一个参数指定。此时在“WATCH”窗口中，可以看到task中下标为5（nr 的值为5）的进程就是新建的子进程，展开后可以查看子进程控制块中各个成员的值，可以看到 新建的子进程控制块中各个成员的值都为0，这是因为之前为进程控制块分配的物理页的内容都 是0造成的（Linux 0.11会将空闲物理页的内容清零）。
![[Pasted image 20241112202557.png]]

4. 按F10单步执行第103行的代码，黄色箭头指向第104行。第103行的代码非常关键，此行代码 将current 指向的父进程控制块中的内容完全复制到了p指向的子进程控制块中，也就是子进程 完全继承了父进程的各种资源。此时在“WATCH”窗口中，可以分别查看父进程task[4]和子进程 task[5]各个成员的值，可以发现它们的值是完全相同的。这就可以解释很多现象，例如子进程 和父进程的优先级相同，使用相同的tty终端，打开了相同的文件等。

从copy_process函数返回时的执行情况：
1. 按F10单步调试，直到从copy_process函数返回到kernel/system_call.s文件中的第280行。 copy_process 函数的返回值是子进程的进程号，会被放入EAX寄存器中，也就是父进程从fork 函数返回时得到的返回值。
2. 按F10单步调试，直到从汇编函数返回到kernel/system_call.s文件中的第120行。 
3. 继续按F10单步调试，直到第133行。可以看到在从fork系统调用返回之前，并没有执行进程 调度reschedule 函数，所以父进程会继续运行。
4. 按F5继续调试，在Bochs的Display窗口中可以看到app可执行文件运行结束。

![[Pasted image 20241112203109.png]]


### 3.2 任务（二）：调用execve函数加载执行一个新程序

#### 调用execve函数加载执行一个新程序


vi 完成old.c与new.c
![[Pasted image 20241112205049.png]]
代码如下：

```C
#define _LIBRARY_
#include <stdio.h>
#include <unistd.h>
int main(int argc , char * argv[]) {
    printf("PID:%d new process.\n",getpid());
    return 0;
}
```

```C
#define _LIBRARY_
#include <stdio.h>
#include <unistd.h>
int main(int argc, char * argv[]) {
    printf("PID:%d old process start.\n",getpid());
    execve("new",NULL,NULL);
    printf("PID:%d old process exit.\n",getpid());
    return 0;
}
```

正常编译运行
![[Pasted image 20241112205511.png]]

2. 使用命令gcc old.c -o old生成可执行文件old。 
3. 执行 chmod +x old命令为old文件添加可执行权限。 
4. 执行sync命令，将文件保存到硬盘。 
5. 使用命令./old运行可执行文件old，注意观察输出的PID的值，以及输出的内容与读者期望的 是否一致，并尝试说明原因。
![[Pasted image 20241114084846.png]]
输出内容显示程序old只执行到execve("new",NULL,NULL);，调用new，然后然后就结束了，没有继续向下执行输出

原因：系统调用execve会清理掉当前进程的内存空间，并释放对应的物理页，然后为新加载的可执行文件 中的指令和数据重新申请内存，并配置到当前进程的进程控制块中，还会将新加载程序的入口点设置为执 行的起始位置。此时当前进程的代码和数据将完全被新程序替换掉，并在该进程中开始执行新程序的代码。 所以在old程序中，调用execve加载new程序后面的代码就没有机会执行了，而是在当前进程中开始执 行new程序了，并且PID保持不变。


#### 调试跟踪execve函数的执行过程
![[Pasted image 20241114090051.png]]
体会execve函数的执行过程，该过程中并没有申请新的进程控制块，同时PID的值也没有发生变化， 只是对当前进程的控制块进行了相应的修改，从而加载执行了另一个程序。