## 一、实验概述
### 1.实验名称
第二讲 操作系统的启动

### 2.实验目的
- 理解并验证操作系统启动过程中的关键步骤。
- 学习如何在Linux 0.11环境中调试操作系统的启动过程。

### 3.实验类型（演示性、验证性、设计研究性）
验证性

### 4. 实验内容
- 准备实验，阅读bootsect.asm和setup.asm两个汇编文件。
- 调试Linux 0.11操作系统的启动过程。
- 查看软盘引导扇区程序生成的列表文件。
- 调试软盘引导扇区程序（bootsect.asm）。
- 查看引导程序将自己复制到0x90000后的情况。
- 调试加载程序（setup.asm）。
- 调试内核模块中的head.s。
- 内核初始化。

## 二、实验环境
- 操作系统：Linux 0.11
- 调试工具：Bochs

## 三、实验过程
### 需要解决的问题及解答
- 如何验证BIOS第一条指令的逻辑地址中的段地址和CS寄存器值是一致的，以及偏移地址和IP寄存器的值是一致的。

### 程序运行时的初值和运行结果
- 通过调试命令和观察物理内存的变化，验证了BIOS中断向量表和软盘引导扇区的加载情况。

### 3.1 准备实验
开boot文件夹中的bootsect.asm和setup.asm两个汇编文件。简单阅读一下这两个文件中的源代码和注释。
![[Pasted image 20241107100950.png]]

使用Task中的“生成项目”完成项目的生成过程后，使用Windows资源管理器打开项目文件夹中的 boot 文件夹。找到由bootsect.asm生成的软盘引导扇区程序bootsect.bin文件，确认该文件的大小为 512 字节
![[Pasted image 20241107100913.png]]

### 3.2 调试 Linux 0.11操作系统的启动过程
1. 找到start函数的代码行(init/main.c文件中的第134行)。 
2. 在此代码行添加一个断点。 
3. 按F5启动调试，会在刚刚添加的断点处中断。 
4. 在start函数名称上双击鼠标左键选中此名称，然后在此名称上点击右键，选择菜单中的“Add to Watch”，可以在左侧的“WATCH”窗口中查看start函数的地址
5. 截图记录地址
6. 结束调试
![[Pasted image 20241107102200.png]]

调试BIOS程序
1. 在Console窗口中输入调试命令sreg后按回车，显示当前CPU中各个段寄存器的值
![[Pasted image 20241107102812.png]]

2. 在Console窗口中输入调试命令 r 后按回车，显示当前CPU中各个通用寄存器的值
![[Pasted image 20241107102944.png]]

3. 输入调试命令xp /1024b 0x0000，查看从地址0开始的1024个字节的物理内存。
![[Pasted image 20241107103153.png]]
在Console 中输出的这1K物理内存的值都为0，说明BIOS中断向量表还没有被加载到从地址0开始的物理内存。

4. 输入调试命令xp /512b 0x7c00，查看软盘引导扇区要被加载到的物理内存。
![[Pasted image 20241107103352.png]]
输出的内存值都为0，说明软盘引导扇区还没有被加载到从地址0x7c00开始的物理内存。

通过以上的实验步骤，可以验证BIOS第一条指令的逻辑地址中的段地址和CS寄存器值是一致的，偏移地址和IP寄存器的值是一致的。由于物理内存还没有被使用，所以其中的值都为0。

### 查看软盘引导扇区程序生成的列表文件
1. 在VSCode的“文件资源管理器”窗口中打开“boot”文件夹，打开其中的bootsect.lst文件。
2. 将bootsect.lst 文件和bootsect.asm 文件对比可以发现，此文件包含了bootsect.asm文件中所 有的汇编代码，同时在代码的左侧又添加了更多的信息。
3. 在bootsect.lst 中查找到软盘引导扇区程序第一条指令所在的行 
```lst
32 00000000 B8C007 mov ax,BOOTSEG
```
![[Pasted image 20241107104841.png]]
4. 在VSCode的“文件资源管理器”窗口中打开“boot”文件夹，在其中的bootsect.bin文件上点 击鼠标右键，在弹出的菜单中选择“Open With…”，会在VSCode的顶部中间位置弹出一个文件 打开方式的列表，选择其中的“Hex Editor”，就会使用二进制编辑器打开此文件。
![[Pasted image 20241107105300.png]]
可以看到 bootsect.bin 文件中的机器码与列表文件bootsect.lst中的机器码是完全一致的。

### 调试软盘引导扇区程序（bootsect.asm）
1. 在Bochs的Console窗口中输入调试命令vb 0x0000:0x7c00，这样就在逻辑地址0x0000:0x7c00 （相当于物理地址0x7c00）处添加了一个断点。
2. 输入调试命令c让Bochs继续执行，会在0x7c00处的断点中断。此时会在Console窗口中输出 下一个要执行的指令，即软盘引导扇区程序的第一条指令，
![[Pasted image 20241107105846.png]]

4. 输入调试命令sreg验证CS寄存器的值（0x0000）
![[Pasted image 20241107110058.png]]

5. 输入调试命令r验证IP寄存器的值（0x7c00）
![[Pasted image 20241107110208.png]]
6. 由于BIOS程序此时已经执行完毕，输入调试命令 xp /1024b 0x0000验证此时BIOS中断向量 表已经被载入。![[Pasted image 20241107110354.png]]
7. 输入xp /512b 0x7c00 显示软盘引导扇区程序的所有字节码。观察此块内存最开始的三个字节 分别是0xb8、0xc0和0x07，这和引导程序第一条指令的字节码是相同的。如果将Bochs的Console 窗口中显示的512个字节与bootsect.lst文件中的机器码进行比较，或者与使用二进制编辑器 打开的bootsect.bin 文件中的内容进行比较，读者会发现它们的内容是完全相同的。此块内存 最后的两个字节分别是0x55和0xaa，它们是魔数，是BIOS规定这两个字节的值必须为0x55和 0xaa 时才表示引导扇区是激活的，可以用来引导操作系统。这两个字节对应bootsect.asm中最 后一行语句（注意，字节顺序使用Little-endian）： dw 0xAA55
![[Pasted image 20241107110713.png]]
![[Pasted image 20241107110741.png]]

接下来查看引导程序将自己复制到0x90000后的情况：

1. 输入调试命令 xp /512b 0x9000:0x0000可以验证此时引导程序还没有将自己移动到 0x9000:0x0000 处。
![[Pasted image 20241107111000.png]]

2. 输入调试命令vb 0x9000:0x0018，在0x9000:0x0018 处设置一个断点。
3. 输入调试命令c继续执行，会在刚刚添加的断点处中断。
![[Pasted image 20241107111242.png]]
4. 再次输入调试命令 xp /512b 0x9000:0x0000，并与之前的内存比较，可以知道引导程序已经 将自己移到了0x90000处，并在0x9000:0x0018处中断执行了。
![[Pasted image 20241107111754.png]]
5. 输入调试命令 xp /512b 0x9000:0x0200，可以验证此时setup.bin模块还没有被装入内存
![[Pasted image 20241107111915.png]]

6. 根据bootsect.lst 文件下面一行的内容（执行此行指令时说明setup.bin加载完毕），输入调试 命令 vb 0x9000:0x0031，在逻辑地址0x9000:0x0031处设置一个断点。 75 00000031 0F830B00 jnc ok_load_setup ; 读取成功
7. 输入调试命令c继续执行，会在刚刚添加的断点处中断。
![[Pasted image 20241107112213.png]]

8. 输入调试命令 xp /512b 0x9000:0x0200，此块内存已经发生改变。将此块内存中的字节码与 boot/setup.lst 文件和 boot/setup.bin 文件中的内容比较，可以知道此时setup.bin模块已经 被载入内存。
![[Pasted image 20241107112755.png]]9. 输入调试命令 xp /512b 0x1000:0x0000，可以看到除前面有少量数据(BIOS自检程序残留下 的)，后面全是0。可以知道此时内核模块linux011.bin还没有被装载进入内存。
![[Pasted image 20241107112906.png]]
10. 根据bootsect.lst 文件下面一行的内容（执行此行指令时说明linux011.bin加载完毕，软盘驱 动器中的马达被关闭了），输入调试命令 vb 0x9000:0x006e，在逻辑地址0x9000:0x006e处设 置一个断点。
11. 输入调试命令c继续执行，会在刚刚添加的断点处中断。
![[Pasted image 20241107113121.png]]
12. 输入调试命令 xp /512b 0x1000:0x0000，显示此块内存中的字节码与boot/head.lst文件（由 init/head.asm 编译时生成）和linux011.bin 文件中开始位置的机器码是完全一致的。原因是 init/head.asm 生成了目标文件init/head.o，此目标文件中的代码段（包括指令的机器码）会 在链接时写入内核模块linux011.bin的代码段的开始位置。由此可知，此时内核模块 linux011.bin 已经被装入物理内存。
![[Pasted image 20241107113328.png]]

### 调试加载程序（setup.asm）
1. 在Bochs的Console窗口中输入调试命令 vb 0x9020:0x0000，在逻辑地址0x9020:0x0000（即 setup 程序的第一条指令）处设置一个断点。
2. 输入调试命令 c继续执行，可在0x9020:0x0000处中断，如图2-6。打开setup.lst文件，可以 看到其中第一条指令的字节码与此处将要执行的指令的字节码是相同的，说明Linux 0.11将要 开始执行setup模块。
![[Pasted image 20241107113618.png]]
3. 输入调试命令 xp /2b 0x9000:0x0000，查看取得各种机器参数之前物理内存0x90000-0x901FF 中前两个字节的值并记录下来，如图2-7。
![[Pasted image 20241107113737.png]]
4. 根据setup.lst 文件下面一行的内容，输入调试命令 vb 0x9020:0x0080。
5. 输入调试命令c继续运行，在刚刚添加的断点处中断。此时Linux 0.11已经将各种机器参数放 入0x90000-0x901FF 的物理内存中。
6. 输入调试命令 xp /2b 0x9000:0x0000，查看此处内存的值，如图2-8，并和步骤3进行对比。 可以知道此时该地址处的内存值已经改变。
![[Pasted image 20241107114006.png]]
7. 根据setup.lst 文件下面一行的内容，输入调试命令vb 0x9020:0x010b。
8. 输入调试命令 c继续运行，可以在刚刚添加的断点处中断。此时，setup.asm已经完成了它的工 作，并让处理器从实模式进入了保护模式，下一条将要执行的跳转指令是工作在保护模式下的， 所以要指定段选择符和偏移，才会跳转到head.s的第一条指令处执行。
![[Pasted image 20241107114150.png]]

### 调试内核模块中的head.s
1. 打开head.lst，找到其第一条指令所在行，如下（此条指令包含了5个字节）： 25 0000 B8100000 movl $0x10,%eax 25 00 在生成Linux 0.11 内核的过程中，head.s会生成目标文件head.o，此目标文件中的代码段在链 接时会写入Linxu011.bin中代码段的开始位置，并且linux011.bin会被从之前的0x10000起始 的物理内存移动到0x00000起始的物理内存。所以，可以在物理地址0x0000处设置一个断点。注意，执行到这里时，CPU已经处于保护模式了，使用在物理地址添加断点的命令比较方便，所 以输入的调试命令为：pb 0x0000。
2. 输入调试命令 c 继续执行，可在图 2-9所示的指令处中断。对比head.lst文件中第一条指令的 字节码，可以确认已经进入了head.s模块。
![[Pasted image 20241107114543.png]]
![[Pasted image 20241107114609.png]]
3. 根据head.lst文件下面一行的内容，输入调试命令：pb 0x540b。 该指令负责将内核入口点函 数start 的地址压入栈。 202 540b 68000000 202 pushl $_start 00
4. 输入调试命令 c 继续执行，在步骤3设置的断点处中断，如图
![[Pasted image 20241107114801.png]]
将图中红框中的地址与之前记录的start函数的地址比较，可以确认这个地址就是start函数的 地址。最终就是通过这个地址跳转到操作系统内核的入口点开始执行，从而结束引导过程的。

5. 根据head.lst文件下面一行的内容，输入调试命令：pb 0x54a5。 316 54a5 C3 ret
6. 输入调试命令c继续执行，在ret指令处中断。然后接着输入调试命令s，单步执行此行的ret 指令，可以得到图
![[Pasted image 20241107114947.png]]
图中红线圈出的是IP寄存器将要执行的下一条指令。对比可以发现它和图2-10中圈出的值是一 样的，说明接下来就开始执行start函数中的指令了。
调试到这里，操作系统启动的部分就全部结束了，接下来操作系统将跳入init/main.c中的start函 数去执行。

### 3.3 内核初始化
1. 结束之前的调试，关闭Bochs虚拟机。
2. 在kernel\chr_drv\tty_io.c文件的tty_read 函数中（第309行）添加一个断点即可。此函数就是终端进程读取用户输入的字符时调用的函数。
3. 按F5启动调试，待Linxu 内核初始化完毕后，就会命中刚刚添加的断点。
4. 在VSCode 的“View”菜单中选择“Command Palette...”，会 在 VSCode的顶部中间位置显示命令面板，输入“Lab: New Visualizer View”命令后，VSCode 会在其右侧弹出一个窗口让读者查看可视化视图。
5. 在右侧可视化视图顶部的编辑框中输入命令“#task”，就可以显示当前系统中所有进程的数据
![[Pasted image 20241107115918.png]]

此时系统中存在四个进程，进程号分别为0、1、4、3。其中current游标是一个 全局变量，用于指向当前正在运行的进程。所以，从图上可以看出，当前正在运行的进程是4号 进程，也就是终端进程，这与添加断点中断执行的位置是吻合的，说明终端进程正在（运行）从 键盘获取用户输入的命令。当然，如果接下来用户没有输入任何命令，终端进程就会进入阻塞状态，让出处理器，调度程序会让0号进程继续运行，直到用户输入命令时将终端进程唤醒继续执 行。
![[Pasted image 20241107120320.png]]
6. 在右侧可视化视图顶部的编辑框中输入命令“#sched”后按回车（需要等待较长时间完成刷新）， 就可以查看进程的运行轨迹。在图中每一行表示所有进程中的某一个进程进入了某个状态，并使 用不同的颜色表示不同的状态（具体看图例），例如第一行表示pid为0的进程进入了运行态，后 面在其运行的过程中创建了pid为1的进程。从图中可以看到进程号为0 的进程是Linux初始化过程中创建的第一个进程，在完成加载系统后，演变为进程调度，交换以 及存储管理进程。然后，以进程0为母本创建进程1，来继续完成系统的初始化，进程1是系统 中所有其它进程的祖先进程。然后，以进程1为母本创建进程号为2的Shell进程。2号进程再创 建进程号为3的update进程，然后进程2就结束了。update进程的主要任务是将缓冲区中的数据同步到外设(软盘和硬盘)。update进程启动后将会被阻塞，然后让进程1继续运行，此时进程 1 会创建一个新的Shell进程接受用户的命令，其进程号为4。进程5是进程4创建的，用于监听 内核异常。当系统出现宕机，可以利用该进程将宕机时的一些堆栈信息写入指定文件，用于事后 分析宕机的原因。当系统正常启动后，进程5结束。这就是Linux 0.11内核的初始化过程。
![[Pasted image 20241107120846.png]]

## 四、实验体会
通过本次实验，我们深入理解了操作系统启动的全过程，从BIOS启动、引导扇区的加载、内核的初始化，到进程的创建和管理。实验中遇到的问题及解决过程、实验中产生的错误及原因分析、实验的体会及收获等如下：

1. **理解启动流程**：通过实际操作和调试，我们更加深刻地理解了操作系统启动的各个阶段，包括BIOS的作用、引导扇区的加载过程、以及操作系统内核的初始化。

2. **调试技巧的提升**：在调试过程中，我们学会了如何使用Bochs虚拟机和调试工具来观察和分析程序的运行状态，包括寄存器的值、内存的变化等，这些技巧对于我们未来在系统开发和调试中非常有帮助。

3. **问题解决能力**：在实验过程中，我们遇到了一些预期之外的问题，例如断点未能正确触发、内存值与预期不符等。通过查阅资料、反复尝试和调试，我们最终解决了这些问题，这个过程锻炼了我们的问题解决能力。

4. **理论与实践的结合**：实验前的理论学习与实验中的实践操作相结合，使我们对操作系统的启动机制有了更加直观的认识，加深了对理论知识的理解。

5. **系统稳定性的认识**：通过观察内核初始化过程中进程的创建和管理，我们对操作系统的稳定性和健壮性有了更深的认识，了解到了操作系统在处理进程调度和资源管理方面的复杂性。

6. **实验中的错误及原因分析**：在实验中，我们遇到了一些错误，例如由于配置错误导致的调试失败，或者由于对指令理解不准确导致的内存地址错误。通过分析这些错误，我们学会了如何排查问题，并理解了精确理解指令和配置的重要性。

7. **实验的体会及收获**：总体来说，本次实验不仅加深了我们对操作系统启动过程的理解，而且提高了我们的实践操作能力和问题解决能力。通过亲手操作和观察，我们对操作系统的内部工作机制有了更加深刻的认识，这将对我们未来的学习和工作产生积极的影响。

通过本次实验，我们不仅学习到了操作系统启动的理论知识，还通过实践操作加深了对这些知识的理解。我们体会到了理论与实践相结合的重要性，并且通过解决实验中遇到的问题，提升了我们的技术能力和问题解决能力。