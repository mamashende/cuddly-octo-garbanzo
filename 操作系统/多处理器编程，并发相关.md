### 多线程内存共享并发入门
”CPU一次执行一条指令“的基本假设在现代计算机系统中是不成立的
需要放弃指令执行的原子性
指令执行的顺序也是不确定的
放弃多处理器之间的可见性
因此需要一些特殊操作来控制线程之间内存共享造成的不确定操作

宽松内存模型
![[Pasted image 20240502144022.png]]
宽松内存模型的目的是使执行效率更高，但是这又带来了大量的问题，例如不同指令集对于内存模型的约束不一样，导致x86上的代码编译出来的操作，无法直接在arm指令集模拟器上直接运行（模拟器在翻译指令时不知道是否可以并行化，保守地统一改为非并行化运行，造成严重的性能损失，某些情况下会造成一些bug）

### 并发控制 peterson算法

atomic
原子操作，读和写
### 互斥
自旋锁，互斥锁
通过交换内存中的值实现自旋锁，但是频繁交换内存会造成性能浪费
以及持有自旋锁的线程可能会被操作系统切换出去，导致剩余线程全部都在空转，造成完全性能浪费
自旋锁的应用场景：操作系统内核的并发数据结构（短临界区）

互斥锁，适用于多线程竞争的情况下的调度，通过队列向线程分发锁
缺点是反应速度不够快，需要操作系统的大量中介，在线程竞争频率低时效率低下

在操作系统中，这两种锁都是存在的，自动选择合适的情况使用

生产者-消费者模型 利用条件变量实现

信号量是互斥锁的扩展