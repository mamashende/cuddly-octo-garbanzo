#### 7.1 工作负载假设
我们对操作系统中运行的进程（有时也叫工作任务）做出如下的假设：
1．每一个工作运行相同的时间。 
<font color="#2DC26B">**2．所有的工作同时到达。**</font>
<font color="#2DC26B">**3．一旦开始，每个工作保持运行直到完成。**</font>
4．所有的工作只是用 CPU（即它们不执行 IO 操作）。 
5．每个工作的运行时间是已知的。
其中一些假设并不现实，例如第五条

#### 7.2 调度指标
周转时间（turnaround time）。
T 周转时间= T 完成时间−T 到达时间
性能和公平在调度系 统中往往是矛盾的。例如，调度程序可以优化性能，但代价是以阻止一些任务运行，这就 降低了公平。

#### 7.3 先进先出（FIFO）
最简单的实现方式，先到先得
缺点：重量级任务可能会长时间占用CPU，导致平均周转时长边长
#### 7.4 最短任务优先（SJF）
对任务进行排序，进一步提高效率
缺点：大量短时任务导致某些重量级任务一直无法运行（如果一直有新任务不停出现的话），
当放宽同时到达的条件时，后来的小任务仍然会被正在运行的重量级的任务堵住（因为假设3的存在）

#### 7.5 最短完成时间优先（STCF）
放宽假设条件（工作必须保持运行直到完成）。我们还需要调 度程序本身的一些机制。你可能已经猜到，鉴于我们先前关于时钟中断和上下文切换的讨 论，当 B 和 C 到达时，调度程序当然可以做其他事情：它可以抢占（preempt）工作 A，并 决定运行另一个工作，或许稍后继续工作 A。

#### 7.6 新度量指标：响应时间
T 响应时间= T 首次运行−T 到达时间
STCF 和相关方法在响应时间上并不是很好。假设你在终端前输入，不得不等待 10s 才能看 到系统的回应，只是因为其他一些工作已经在你之前被调度：你肯定不太开心。 因此，我们还有另一个问题：如何构建对响应时间敏感的调度程序？

#### 7.7 轮转
##### 轮转（Round-Robin， RR）调度
RR 在一个时间片（time slice，有时称为调度量子，scheduling quantum）内运行一个工作，然后切换到运行队列中的下一个任务，而不是运行一个任务直 到结束。它反复执行，直到所有任务完成。因此，RR 有时被称为时间切片（time-slicing）。 请注意，时间片长度必须是时钟中断周期的倍数。因此，如果时钟中断是每 10ms 中断一次， 则时间片可以是 10ms、20ms 或 10ms 的任何其他倍数。
时间片长度对于 RR 是至关重要的。越短，RR 在响应时间上表现越好。然而，时间片太短是有问题的：突然上下文切换的成本将影响整体性能。

如果周转时间是我们的指标，那么 RR 确实是最糟糕的策略之一。直观地 说，这应该是有意义的：RR 所做的正是延伸每个工作，只运行每个工作一小段时间，就转 向下一个工作。因为周转时间只关心作业何时完成，RR 几乎是最差的，在很多情况下甚至 比简单的 FIFO 更差。
追求公平，效率就会大打折扣

#### 7.8 结合 I/O
首先，我们将放宽假设 4：当然所有程序都执行 I/O。
调度程序显然要在工作发起 I/O 请求时做出决定，因为当前正在运行的作业在 I/O 期间 不会使用 CPU，它被阻塞等待 I/O 完成。如果将 I/O 发送到硬盘驱动器，则进程可能会被阻 塞几毫秒或更长时间，具体取决于驱动器当前的 I/O 负载。因此，这时调度程序应该在 CPU 上安排另一项工作。

通过将每个 CPU 突发作为一项工作， 调度程序确保“交互”的进程经常运行。当这些交互式作业正在执行 I/O 时，其他 CPU 密 集型作业将运行，从而更好地利用处理器。

#### 7.9 无法预知
事实上，在一个通用的操作系统中（比如我们 所关心的操作系统），操作系统通常对每个作业的长度知之甚少。因此，我们如何建立一个 没有这种先验知识的 SJF/STCF？更进一步，我们如何能够将已经看到的一些想法与 RR 调 度程序结合起来，以便响应时间也变得相当不错？
