内存虚拟地址(逻辑地址)到实际物理地址存在一定的转换方式
为基于硬件的地址转换
利用地址转换，硬件对每次内存访问进行处理（即指令获取、数据读取或写 入），将指令中的虚拟（virtual）地址转换为数据实际存储的物理（physical）地址。因此， 在每次内存引用时，硬件都会进行地址转换，将应用程序的内存引用重定位到内存中实际 的位置。

### 动态（基于硬件）重定位
每个 CPU 需要两个硬件寄存器：基址（base）寄存器和界限（bound）寄存 器，有时称为限制（limit）寄存器。这组基址和界限寄存器，让我们能够将地址空间放在物 理内存的任何位置，同时又能确保进程只能访问自己的地址空间。 采用这种方式，在编写和编译程序时假设地址空间从零开始。但是，当程序真正执行时， 操作系统会决定其在物理内存中的实际加载地址，并将起始地址记录在基址寄存器中。

physical address = virtual address + base

程序计数器（PC）首先被设置为 128。当硬件需要获取这条指令时，它先将这个值加上基 址寄存器中的 32KB(32768)，得到实际的物理地址 32896，然后硬件从这个物理地址获取指令。 接下来，处理器开始执行该指令。这时，进程发起从虚拟地址 15KB 的加载，处理器同样将虚 拟地址加上基址寄存器内容（32KB），得到最终的物理地址 47KB，从而获得需要的数据。

进程中使用的内存引用都是虚拟地址（virtual address），硬件接下来将虚拟地址加上基 址寄存器中的内容，得到物理地址（physical address），再发给内存系统。

### 动态定位所需的硬件支持


![[Pasted image 20240912212636.png]]

### 操作系统支持动态定位的操作
第一，在进程创建时，操作系统必须采取行动，为进程的地址空间找到内存空间。

第二，在进程终止时（正常退出，或因行为不端被强制终止），操作系统也必须做一些 工作，回收它的所有内存，给其他进程或者操作系统使用。在进程终止时，操作系统会将 这些内存放回到空闲列表，并根据需要清除相关的数据结构。

第三，在上下文切换时，操作系统也必须执行一些额外的操作。

需要注意，当进程停止时（即没有运行），操作系统可以改变其地址空间的物理位置，这 很容易。要移动进程的地址空间，操作系统首先让进程停止运行，然后将地址空间拷贝到新 位置，最后更新保存的基址寄存器（在进程结构中），指向新位置。



第四，操作系统必须提供异常处理程序（exception handler），或要一些调用的函数，像 上面提到的那样。操作系统在启动时加载这些处理程序（通过特权命令）。例如，当一个进 程试图越界访问内存时，CPU 会触发异常。在这种异常产生时，操作系统必须准备采取行 动。通常操作系统会做出充满敌意的反应：终止错误进程。操作系统应该尽力保护它运行 的机器，因此它不会对那些企图访问非法地址或执行非法指令的进程客气。再见了，行为 不端的进程，很高兴认识你。

这个简单的动态重定位技术有效率低下的问题。重定位的进程使用了从 32KB 到 48KB 的物理内存，但由于该进程的栈区和堆区并不很大， 导致这块内存区域中大量的空间被浪费。这种浪费通常称为内部碎片（internal fragmentation）， 指的是已经分配的内存单元内部有未使用的空间（即碎片），造成了浪费。