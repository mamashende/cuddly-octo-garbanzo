为了解决内部碎片问题

### 分段：泛化的基址/界限
在 MMU 中引入不止 一个基址和界限寄存器对，而是给地址空间内的每个逻辑段（segment）一对。一个段只是 地址空间里的一个连续定长的区域，在典型的地址空间里有 3 个逻辑不同的段：代码、栈 和堆。分段的机制使得操作系统能够将不同的段放到不同的物理内存区域，从而避免了虚 拟地址空间中的未使用部分占用物理内存。只有已用的内存才在物理内存中分配空间，因此可以容纳巨大的地 址空间，其中包含大量未使用的地址空间（有时又称为稀疏地址空间，sparse address spaces）。

### 我们引用哪个段
硬件在地址转换时使用段寄存器。它如何知道段内的偏移量，以及地址引用了哪个段？

显式（explicit）方式，就是用虚拟地址的开头几位来标识 不同的段，VAX/VMS 系统使用了这种技术

如果前两位是 00，硬件就知道这是属于代码段的地址，因此使 用代码段的基址和界限来重定位到正确的物理地址。如果前两位是 01，则是堆地址，对应 地，使用堆的基址和界限。

在隐式（implicit）方式中，硬件通过地 址产生的方式来确定段。例如，如果地址由程序计数器产生（即它是指令获取），那么地址 在代码段。如果基于栈或基址指针，它一定在栈段。其他地址则在堆段。


到目前为止，我们一直没有讲地址空间中的一个重要部分：栈。但有一点关键区别，它反向增长。在物理内存中，它始于 28KB， 增长回到 26KB，相应虚拟地址从 16KB 到 14KB。地址转换必须有所不同。首先，我们需要一点硬件支持。除了基址和界限外，硬件还需要知道段的增长方向（用 一位区分，比如 1 代表自小而大增长，0 反之）


### 支持共享
为了支持共享，需要一些额外的硬件支持，这就是保护位（protection bit）。基本为每个段增加了几个位，标识程序是否能够读写该段，或执行其中的代码。通过将代码段标记为只 读，同样的代码可以被多个进程共享，而不用担心破坏隔离。虽然每个进程都认为自己独占 这块内存，但操作系统秘密地共享了内存，进程不能修改这些内存，所以假象得以保持。

### 操作系统支持

然而，分段也带来了一些新的问题。我们先介绍必须关注的操作系统新问题。第一个 是老问题：操作系统在上下文切换时应该做什么？你可能已经猜到了：各个段寄存器中的 内容必须保存和恢复。显然，每个进程都有自己独立的虚拟地址空间，操作系统必须在进 程运行前，确保这些寄存器被正确地赋值。

第二个问题更重要，即管理物理内存的空闲空间。

一般会遇到的问题是，物理内存很快充满了许多空闲空间的小洞，因而很难分配给新 的段，或扩大已有的段。这种问题被称为外部碎片（external fragmentation）

该问题的一种解决方案是紧凑（compact）物理内存，重新安排原有的段。但是，内存紧凑成本很高，因为拷贝段是内存密集型的，一般会 占用大量的处理器时间。一种更简单的做法是利用空闲列表管理算法，试图保留大的内存块用于分配。相关的 算法可能有成百上千种，包括传统的最优匹配（best-fit，从空闲链表中找最接近需要分配空 间的空闲块返回）、最坏匹配（worst-fit）、首次匹配（first-fit）以及像伙伴算法（buddy algorithm） 这样更复杂的算法。

但遗憾的是，无论 算法多么精妙，都无法完全消除外部碎片，因此，好的算法只是试图减小它。

存在如此多不同的算法来尝试减少外部碎片，正说明了解决这个问题没有最好的办法。