### 线程性质
经典观点是一个程序只有 一个执行点（一个程序计数器，用来存放要执行的指令），但多线程（multi-threaded）程序 会有多个执行点（多个程序计数器，每个都用于取指令和执行）。换一个角度来看，每个线 程类似于独立的进程，只有一点区别：它们共享地址空间，从而能够访问相同的数据。


线程有一个程序计数器（PC），记录程序从哪里获取指令。每个线程有自己的一组用于计算的寄存器。所以，如果有两个线程运行 在一个处理器上，从运行一个线程（T1）切换到另一个线程（T2）时，必定发生上下文切 换（context switch）。

#### TCB

线程切换需要一个或多个线程控制块（Thread Control Block，TCB），保存每个线程的状态。但是，与进程相比，线程之间的上下文切换有一点主要区别：地址空间保持不变（即不需要切换当前使用的页表）。

#### 线程地址空间特点
![[Pasted image 20240906190335.png]]

所有位于栈上的变量、 参数、返回值和其他放在栈上的东西，将被放置在有时称为线程本地（thread-local）存储的 地方，即相关线程的栈。
线程局部变量应该是线程私有的，其他线程不应该访问。线程之间共享数据，值要在堆（heap）或者其他全局可访问的位置。

#### 线程共享内存空间与临界区操作
临界区是多个线程访问共享资源的一段代码，资源通常是一个变量或数据结构。


#### 原子性操作
当指令执行时，它会像期望那样执行更新。它不能在指令中间中断，因为这正是我们 从硬件获得的保证：发生中断时，指令根本没有运行，或者运行完成，没有中间状态。

##### 课后练习题
一个奇怪的地方，他们的简化汇编代码与国内教材上的有所区别
对于双地址操作，源地址与目的地址是反过来的
```asm
mov R1 R2
```

按照国内教材的约定：R1是目的地址，R2是源地址
按照国外教材的约定：R1是源地址，R2是目的地址
这也解释了为什么让gpt去写计组的汇编题时会大错特错，因为它按照国外标准来的


这些实验验证了中断对于线程运行正确性的影响