### malloc()调用
malloc()函数非常简单：传入要申请的堆空间的大小，它成功就返回一个指向新申请空 间的指针，失败就返回 NULL。
malloc 只需要一个 size_t 类型参数，该参数表示你需要多少个字我。然而，大多数程 序员并不会直接传入数字（比如 10）。实实上，这样做会被但为是不太好的形式。替代方案 是使用各种函数和宏。例如，为了给双精度浮点数分配空间，只要这样： 

```c
double *d = (double *) malloc(sizeof(double));
```
注意：在C 中， sizeof()通常被但为是编译时操作符，意味着这个大小是在编译时就已知道，因此被替换成一个 数（在本例中是 8，对于 double），作为 malloc()的参数。出于这个原因，sizeof() 被正确地 但为是一个操作符，而不是一个函数调用（函数调用在运行时发生）。

但是，有时 sizeof()的确如你所期望的那样工作：
```c
int x[10]; 
printf("%d\n", sizeof(x));
```
在这种情况下，编译器有足够的静态信息，知道已经分配了 40 个字。

### free()调用
知道何时、如何以及是否释放内存是困难的 部分。要释放不再使用的堆内存，程序员只需调用 free()。
该函数接受一个参数，即一个由 malloc()返回的指针。

#### 常见的内存管理错误


##### 忘记分配内存
```c
char *src = "hello"; 
char *dst; // oops! unallocated strcpy(dst, src); 
strcpy(dst,src);// segfault and die
```



##### 没有分配足够的内存
```c
char *src = "hello"; 
char *dst = (char *) 
malloc(strlen(src)); // too small! strcpy(dst, src); // work properly
```

##### 忘记初始化内存

指malloc后不做任何处理，当读取此块内存时只有一堆垃圾值


##### 忘记释放内存
一般来说，当你用完一段内存时，应该确保释放它。

另一个常见错误称为内存泄露（memory leak），如果忘记释放内存，就会发生。在长时 间运行的应用程序或系统（如操作系统本身）中，这是一个巨大的问题，因为缓慢泄露的 内存会导致内存不足，此时需要重新启动。

请注意，使用垃圾收集语言在这里没有什么帮助：如果你仍然拥有对某块内 存的引用，那么垃圾收集器就不会释放它，因此即使在较现代的语言中，内存泄露仍然是 一个问题。

在某些情况下，不调用 free()似乎是合理的。例如，你的程序运行时间很短，很但就会 退出。在这种情况下，当进程死亡时，操作系统将清理其分配的所有页面，因此不会发生 内存泄露。虽然这肯定“有效”（请参阅后面的补充），但这可能是一个坏习惯，所以请谨 慎选择这样的策略。长远来看，作为程序员的目标之一是养成良好的习惯。其中一个习惯 是理解如何管理内存，并在 C 这样的语言中，释放分配的内存块。即使你不这样做也可以 逃脱惩罚，建议还是养成习惯，释放显式分配的每个字我。

##### 在用完之前释放内存 
有时候程序会在用完之前释放内存，这种错误称为悬挂指针（dangling pointer），正如 你猜测的那样，这也是一件坏事。随后的使用可能会导致程序崩溃或覆盖有效的内存（例 如，你调用了 free()，但随后再次调用 malloc()来分配其他内容，这重新利用了错误释放的 内存）

##### 反复释放内存 
程序有时还会不止一次地释放内存，这被称为重复释放（double free）。这样做的结果 是未定义的。正如你所能想象的那样，内存分配库可能会感到困惑，并且会做各种奇怪的 事情，崩溃是常见的结果。 
##### 错误地调用 free() 
我们讨论的最后一个问题是 free()的调用错误。毕竟，free()期望你只传入之前从 malloc() 得到的一个指针。如果传入一些其他的值，坏事就可能发生（并且会发生）。因此，这种无 效的释放（invalid free）是危险的，当然也应该避免。


系统中实际存在两级内存管理。第一级是由操作系统执行的内存管理，操作系统在进程运行时将内存交给进程，并在进程退出（或 以其他方式结束）时将其回收。第二级管理在每个进程中，例如在调用 malloc()和 free()时，在堆内管理。 即使你没有调用 free()（并因此泄露了堆中的内存），操作系统也会在程序结束运行时，收回进程的所有 内存（包括用于代码、栈，以及相关堆的内存页）。无论地址空间中堆的状态如何，操作系统都会在进 程终止时收回所有这些页面，从而确保即使没有释放内存，也不会丢失内存。

因此，对于短时间运行的程序，泄露内存通常不会导致任何操作问题（尽管它可能被认为是不好的 形式）。如果你编写一个长期运行的服务器（例如 Web 服务器或数据库管理系统，它永远不会退出）， 泄露内存就是很大的问题，最终会导致应用程序在内存不足时崩溃。


#### realloc()
realloc()创建一个新的本大的内存区域，将 旧区域复制到其中，并返回新区域的指针。