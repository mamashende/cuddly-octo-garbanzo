虽然但是，不想在系统编程上消耗太多时间，知道个大概就行

### 习题1

是考查fork出去的进程与父进程之间的变量是一种拷贝操作，因此不存在并发修改同一内存区域的情况，具有独立性

简要结论：进程不共享内存

### 习题2
经过实测，以及变形的2.1进一步测试表明子进程与父进程在需要同时输出至同一文件时，在未超出输出缓冲区限制的状态下，具有先后顺序,而且观察到奇怪的现象，输出到文件的内容出现了重复
总结起来，子进程的内存区块与父进程是独立的，它们有各自独立的用户级虚拟地址空间。但子进程会继承父进程的打开文件描述符，使得子进程可以访问父进程打开的文件，并且子进程和父进程之间共享文件的偏移量。
父进程与子进程实际上具有执行顺序，而不是并行
这也解释了父进程与子进程的输出是完整独立可分的，而不是参杂在一起：进程a输出完毕，更新文件偏移量->进程b根据新的文件偏移量继续输出
为我解释下面的c代码的输出异常：字符串"helllllllllo"被输出了两次。当注释掉输出到文件更改为标准输出时输出又正常
```C
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<fcntl.h>
#include <linux/stat.h>
#include<sys/stat.h>
int main(int argc, char *argv[]){
    //printf("hello world (pid :%d)\n",(int)getpid());
    close(STDOUT_FILENO);
    open("./2.output",O_CREAT|O_WRONLY|O_TRUNC, S_IRWXU);
    printf("helllllllllo\n");
    int rc = fork();
    if(rc < 0){
        fprintf(stderr,"fork failed\n");
        exit(1);
    } else if(rc == 0){
        printf("hello , I am child (pid :%d )\n",(int)getpid());

    }else{
        printf("hello ,I am parent of %d (pid :%d)\n",rc,(int)getpid());
    }
    
    return 0;
    
}
```

gpt给出的解释
这段 C 代码的输出异常是由于在调用 `fork()` 函数后，子进程继承了父进程的文件描述符，包括标准输出。因此，当父进程调用 `printf("helllllllllo\n")` 输出字符串时，子进程也会输出相同的字符串。

在代码中，通过关闭标准输出文件描述符 `STDOUT_FILENO`，并将文件 `"./2.output"` 打开作为新的标准输出，你实际上将输出流重定向到了文件中。这导致了以下情况：

1. 在调用 `printf("helllllllllo\n")` 之前，标准输出已经被关闭，此时数据被缓存。
    
2. 在调用 `fork()` 后，子进程继承了父进程的文件描述符，包括缓冲区中的数据。
    
3. 父进程和子进程都会执行 `printf("helllllllllo\n")`，导致字符串被输出两次。
    

当你注释掉输出到文件的部分，恢复为标准输出时，输出正常的原因是标准输出没有被关闭，所以没有发生数据缓存和重定向的情况。


详细解释：
在调用 `printf("helllllllllo\n")` 之前，标准输出被关闭，导致输出的数据被缓存在内存中而不是立即写入到目标设备（例如终端或文件）。

在标准C库中，输出函数（如 `printf`）通常使用缓冲区来提高效率。当输出被执行时，数据会先被写入到缓冲区中，而不是直接发送到目标设备。缓冲区是一个临时存储区域，用于暂时保存输出数据。

只有当缓冲区满了、遇到换行符 `\n`、或者显式调用了刷新函数（如 `fflush`）时，缓冲区中的数据才会被写入到目标设备。

在这段代码中，关闭了标准输出文件描述符 `STDOUT_FILENO`，这会导致标准输出的缓冲区无法进行正常的刷新和写入操作。因此，调用 `printf("helllllllllo\n")` 时，数据会被缓存在内存中。

在调用 `fork()` 之后，子进程会继承父进程的内存状态，包括缓冲区中的数据。因此，子进程也会输出相同的缓冲区数据，导致字符串被输出了两次。

请注意，当程序正常终止时，缓冲区中的数据会自动被刷新并写入到目标设备。然而，在这个特定的情况下，由于关闭了标准输出，缓冲区的数据无法被正常刷新和写入，因此需要采取其他措施来解决重复输出的问题。

CSAPP中对fork的解释
新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的(但是独立的)一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用 fork 时，子进程可以读写父 进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的 PID.


简而言之就是在关闭标准输出后，重定向到文件输出，执行到printf("helllllllllo\n")时会停下来，先执行了fork再在父进程与子进程同时继续执行printf("helllllllllo\n")

解决办法很简单，不关闭标准输出，由标准输出重定向至文件输出即可避免异常输出
### 习题4
https://www.cnblogs.com/xuelisheng/p/10072362.html
参考这篇，这堆函数参数列表有点啰里啰唆的


### 习题5
父进程下wait返回子进程pid，子进程下wait返回-1

### 习题6
父进程下使用waitpid,返回子进程pid


### 习题7
就是习题2描述的现象见习题2


### 习题8


https://www.cnblogs.com/kunhu/p/3608109.html
参考这个
