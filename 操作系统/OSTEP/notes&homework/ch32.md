## 常见并发问题


### 非死锁缺陷

#### 违反原子性缺陷
更正式的违反原子性的定义是：“违反了多次内存访问中预期的可串行 性（即代码段本意是原子的，但在执行中并没有强制实现原子性）”


MySqL中出现的例子：
两个线程都要访问 thd 结构中的成员 proc_info。第一个线程检查 proc_info 非空，然后打印出值；第二个线程设置其为空。显然，当第一个线程检查之后，在 fputs() 调用之前被中断，第二个线程把指针置为空；当第一个线程恢复执行时，由于引用空指针， 导致程序奔溃

解决办法：合理加锁

### 违反顺序缺陷
设计时默认线程1先于线程2运行，2中有依赖1运行的变量
但是线程2先于线程1运行就会造成崩溃


解决办法：使用条件变量实现线程同步

### 死锁缺陷
大型项目中的组建之间的复杂依赖可能导致死锁的发生
模块化封装有时与锁不是很契合

#### 产生死锁的条件
- 互斥：线程对于需要的资源进行互斥的访问（例如一个线程抢到锁）。
- 持有并等待：线程持有了资源（例如已将持有的锁），同时又在等待其他资源（例 如，需要获得的锁）。 
- 非抢占：线程获得的资源（例如锁），不能被抢占。 
- 循环等待：线程之间存在一个环路，环路上每个线程都额外持有一个资源，而这 个资源又是下一个线程要申请的。 
如果这 4 个条件的任何一个没有满足，死锁就不会产生。

### 预防死锁产生


#### 防止循环等待
获取锁时提供一个全序（total ordering）
Linux 中的内存映射代码就 是一个偏序锁的好例子。代码开头的注释表明了 10 组不同的加锁顺序，包括简单的关系，比如 i_mutex早于 i_mmap_mutex，也包括复杂的关系，比如 i_mmap_mutex早于 private_lock，早于 swap_lock，早于 mapping->tree_lock
全序和偏序都需要细致的锁策略的设计和实现
这种方法存在的问题：顺序只是一种约定，粗心的程序员很容易忽略，导致死锁。

#### 持有并等待

这需要任何线程在任何时候抢占锁时，先抢到全局的 prevention 锁。
出于某些原因，这个方案也有问题。和之前一样，它不适用于封装：因为这个 方案需要我们准确地知道要抢哪些锁，并且提前抢到这些锁。因为要提前抢到所有锁（同 时），而不是在真正需要的时候，所以可能降低了并发。

#### 非抢占

#### 互斥
最后的预防方法是完全避免互斥。通常来说，代码都会存在临界区，因此很难避免互斥。

使用硬件原子指令实现临界区值的修改，无须获取锁

#### 通过调度避免死锁


#### 检查和恢复
最后一种常用的策略就是允许死锁偶尔发生，检查到死锁时再采取行动。很多数据库系统使用了死锁检测和恢复技术。死锁检测器会定期运行，通过构建资源 图来检查循环。当循环（死锁）发生时，系统需要重启。