- 书中对于并发的描述都是基于线程的，而专业课中的并发都是基于进程的，哪一种是更符合实际的
		答：专业课教材避重就轻，跳过了计算机硬件与操作系统在并发控制的许多有实际应用的技术细节,架空形式向我们讲述并发控制的各种概念
		所以专业课看看就得了，不要当真
		或者说，教材避开了多线程编程的复杂性去讨论并发（虽然基于进程也可以实现，但是这与实际应用差了好远）
- 目前了解到有锁、条件变量、信号量。这几种实现并发的方法之间有什么关系与区别。
		根据目前所学可知：锁是实现并发所需的最基础操作，需要基于计算机硬件与操作系统的底层支持才能够实现。
		而条件变量则是基于锁实现的更高级的一种管理线程并发的数据结构（需要持有锁才能进行访问的队列）
		信号量可以通过锁与条件变量的结合实现，也可以通过操作系统以及硬件支持

- 多线程程序线程之间竞争资源的情况下，一部分线程休眠，此时这些线程的程序计数器指向代码的哪一部分，什么情况下会指向线程休眠前的代码处，什么情况下会重置至获取锁的代码处？
		### 线程休眠时的程序计数器指向情况：

1. **指向线程休眠前的代码处**：
    
    - **等待条件变量信号的线程**：当线程在条件变量等待时被唤醒，程序计数器通常会指向条件变量等待之后的代码，即线程被唤醒后继续执行的位置。
    - **等待 IO 完成的线程**：当线程在进行阻塞 IO 操作时，被唤醒后通常会继续执行 IO 操作的后续代码。
2. **重置至获取锁的代码处**：
    
    - **获取锁被阻塞的线程**：当线程尝试获取锁时被阻塞，一旦获得锁之后，程序计数器会重置至获取锁的代码处，以继续执行临界区内的代码。

	### 其他情况下，程序计数器的指向可能取决于以下因素：

	- **线程调度策略**：操作系统的线程调度策略会影响线程的执行顺序，可能导致程序计数器指向不同位置。
	- **线程状态转换**：线程状态的变化（如就绪、运行、阻塞、终止）也会影响程序计数器的指向。
	- **异常处理**：如果线程遇到异常情况，程序计数器可能会指向异常处理代码。