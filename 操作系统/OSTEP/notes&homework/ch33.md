简要了解基于事件的并发
部分用于web后端服务器的架构（例如Node.js）


#### 事件循环
```c
while (1) { 
	events = getEvents(); 
	for (e in events) 
		processEvent(e); 
}
```
主循环等待某些事件发生（通过 getEvents()调用），然后依次处理这 些发生的事件。处理事件的代码叫作事件处理程序（event handler）。重要的是，处理程序在 处理一个事件时，它是系统中发生的唯一活动。因此，调度就是决定接下来处理哪个事件。 这种对调度的显式控制，是基于事件方法的一个重要优点。

使用单个 CPU 和基于事件的应用程序，并发程序中发现的问题不再存在。具体来说， 因为一次只处理一个事件，所以不需要获取或释放锁。基于事件的服务器不能被另一个线程中断，因为它确实是单线程的。

#### 通过异步I/O解决阻塞系统调用问题
asynchronous I/O
如果某个事件要求你发出可能会 阻塞的系统调用，该怎么办？
例如，假定一个请求从客户端进入服务器，要从磁盘读取文件并将其内容返回给发出 请求的客户端（很像简单的 HTTP 请求）。为了处理这样的请求，某些事件处理程序最终将 不得不发出 open()系统调用来打开文件，然后通过一系列 read()调用来读取文件。当文件被 读入内存时，服务器可能会开始将结果发送到客户端。
open()和 read()调用都可能向存储系统发出 I/O 请求（当所需的元数据或数据不在内存 中时），因此可能需要很长时间才能提供服务。使用基于线程的服务器时，这不是问题：在 发出 I/O 请求的线程挂起（等待 I/O 完成）时，其他线程可以运行，从而使服务器能够取得 进展。事实上，I/O 和其他计算的自然重叠（overlap）使得基于线程的编程非常自然和直接。 但是，使用基于事件的方法时，没有其他线程可以运行：只是主事件循环。这意味着 如果一个事件处理程序发出一个阻塞的调用，整个服务器就会这样做：阻塞直到调用完成。 当事件循环阻塞时，系统处于闲置状态，因此是潜在的巨大资源浪费。因此，我们在基于 事件的系统中必须遵守一条规则：不允许阻塞调用。

### 存在的问题
#### 基于事件的方法的另一个问题是，这种代码通常比传统的基于线程的代码更复杂。


#### 在现代多核系统上，无锁的简单事件处理已不再可能

