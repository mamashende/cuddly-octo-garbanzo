https://oi-wiki.org/dp/basic/

与分治算法的区别：分治算法划分的子问题具有独立性，但是动态规划的子问题之间具有关联

原问题的最优解包含子问题的最优解
反证法：
总问题的最优解 = 当前状态最优解 + 子问题的最优解
当前状态最优解已定

假设子问题的解不是最优解，那么一定能够找到一个更优的子问题的解，然后用这个新解替换原来的解，此时总问题的新解也一定优于原来总问题的解，由此矛盾

综上可证


找出最优解的性质，并刻画其结构特征
递归定义最优值
自底向上的方式计算出最优值
根据计算最优值时得到的信息，构造最优解

最优解是一系列最优值构成的序列


问题:局部最优解与子问题的最优解这两个描述是否有区别
目前已知的是局部最优解构成的解不一定是整体最优解
但是子问题的最优解能够构成整体最优解
一个小问题：是否存在多个最优解
可以存在多个最优解，而且可以求出所有的最优解序列（但是很多时候没有必要）

如果用图论的思想理解，我们建立一个 [有向无环图](https://oi-wiki.org/graph/dag/)，每个状态对应图上一个节点，决策对应节点间的连边。这样问题就转变为了一个在 DAG 上寻找最长（短）路的问题

例子：带权有向无环图上的起始点到终点的最短路径求解
递归求解：
从终点开始倒推，求解离终点最近的节点，保存各个路径的距离，作为子问题



书上例子：
#### 矩阵连乘问题
目标，求n个矩阵构成的可乘序列的连续乘法的最小运算次数以及最优运算顺序
矩阵A(m,n)
A1(m,n)A2(n,l)
对于矩阵连乘的乘法次数，即为mnl
构造序列p下标从0开始，p0 = m,p1 = n,p2 = l,即 p0p1p2 = mnl

存在最优子结构
对于矩阵连乘序列A[i，j],存在
最小乘法运算次数 m[i,j] = min{m[i,k] + m[k+1,j] + p[i-1]p[k]p[j]}
其中 
(i >= k >= j) k作为最优切分点，可以取区间中的所有值。


### LCS
最长公共子序列问题

**子序列** 是从 ![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "S") 序列中将若干元素提取出来并不改变相对位置形成的序列
https://lcs-demo.sourceforge.net/
https://www.cnblogs.com/-Wallace-/p/bit-lcs.html

给定一个长度为n的序列A和一个长度为m的序列B，求出一个最长的序列，使得该序列既是A的子序列，也是B的子序列

设最优值f(i,j)
为A的前i个元素与B的前j个元素中最长公共子序列长度

子问题就是A[0,i]与B[0,j]中的最长公共子序列的长度
f(i,j)就是状态，f(n,m)就是最终要达到的状态
![[Pasted image 20240923224248.png]]
### 凸多边形最优三角剖分


通过模拟剖分的过程可以了解到,剖分多边形存在最优子结构性质，且与矩阵连乘的最优子结构相似
即n+1边形的剖分与n个矩阵连乘积的最优值相似，只不过是剖分时产生的权值部分与连乘的不一样


#### 流水线作业调度问题




#### 01背包问题
m(i,j) = max{m(i + 1,j),m(i + 1,j - w[i]) + v[i]} (j >= w[i])

递归解与非递归解

直接实现上面这个递归方程的解，其实是一种暴力枚举操作，因为在每一个可以选择的分支都发生了分叉，当可以选择的物品个数为n时，总的分叉数可以达到2^n




### 不是特别恰当的总结
在一些简单的例子里，动态规划的过程就是通过状态转移方程去自底向上去填充一个数组的过程