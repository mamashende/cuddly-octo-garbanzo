字符串也好，数组也好，切片也好

在Go中，这些基础数据结构都是被抽象过的，而不是像C那样直接明确地排列在内存中，我们能够看到的所有基本类型构成的线性数据结构几乎都是被抽象成两部分：一个记录信息的结构体+底层数组

底层数组的内存管理由go自动实现

因此，对于初学者经常容易迷糊的浅拷贝与深拷贝（引用与拷贝）
在go中，拷贝操作的内存是自动管理的，例如对于一个递归函数，传入的字符串不做修改，此时传参时虽然是深拷贝，但是仅拷贝字符串结构体，不拷贝底层数组,也就是说即使发生拷贝，此时所有的字符串副本还是共享底层的数组，当有副本被修改时才会自动开辟新的空间存放修改后的值

对于切片，大部分情况就是浅拷贝了，当生成一个数组的切片时，切片结构体引用数组的底层数组，当向一个空切片中添加数据时，自动开辟内存空间，用一个底层数组存储数据
一个切片的值复制给另一个切片的操作，对于切片结构体本身来说是完全的深拷贝，但是由于不改动底层数组，底层上是浅拷贝
简而言之，这个时候底层数组的引用有多个拷贝

这样可能会有一些潜在的问题，例如通过某个引用副本修改底层数组，然后其他的副本访问底层数组时出现越界错误，或者不一致的数据

因此对于切片操作，首先要知道这是一个引用，因此需要避开直接修改引用的数据

如果需要修改数据，请先用make申请一个新的空切片，然后用copy实现底层数组的复制（如果用 '='直接赋值是浅拷贝，就会造成问题）