背景题目：有一个序列A，可以对其进行如下两种操作：
- 将其中一个元素加上某一个特定的整数x
- 求从序列中序列下标从m到n的元素的和，0 <= m < n <= A.size() -1

基本思路：
第二个操作可以通过前缀和作差快速实现 : c[n] - c[m -1]
既然要求前缀和，那么
第一个操作，就需要维护一个序列A的前缀和序列C
在A中元素值被更改后，自动维护所有包含A中目标元素的序列C中元素的值


问题：这样做的复杂度高且效率低，甚至不如直接累加，需要大量操作用于维护一些不一定用得上的前缀和

改进：树形数组S
![[Pasted image 20240809194349.png]]
如同：不同的层的值有不同的形式，
1层只存储本身的值：s1 = a1
s3 = a3 , s5 =a5

2层 : s2 = a1 + a2 = c2 , s6 = a5 + a6 = c6 - c4

3层 : s4 = c4 , s12 = c12 - c9 


通过将前缀和拆分成这种树形数组实现减少前缀和维护次数以及可能需要的差分次数



树状数组按照上图进行排列即可实现前缀和的快速维护

如何实现这种排列:

通过lowbit(x)划分树状数组
```
lowbit(x)
x的二进制表示中，最低的为1的位的位权

即为最大的能整除x的2的n次幂,n即为所求
lowbit(3) = 2^(0)
lowbit(4) = 2^(2)
lowbit(5) = 2^(1)
```

当a2的值需要修改时，同步将修改扩散至s2,s4,s8 即可完成维护
只需要log(n)级的操作次数即可完成
但是在求特定的分段[m,n]的和时，需要将这些分离的段进行动态的组合实现求特定分段的和
当需要求特定分段的和时，例如a3到a6的和
 即为 c6 - c2 -> s6 + s4 - s2


对于维护与求和过程，都需要lowbit()的参与:

![[Pasted image 20240809201917.png]]
注:
图里的c[i]在这篇文章中是s[i]

这里的求和采用先求前缀和再作差的方法规避掉碎片求和的复杂实现，由于只需要log(n)级的操作次数，比枚举求和更快

重点：
lowbit()的实现
```
lowbit(x) = x(B) & [-x](B)
即为x的二进制原码按位与他的变补
```

序列S的划分初始化实现
假设原序列A一共有N个元素，那么一共需要分为k层，满足 
```
k = floor(log(N)) + 1



最高层k只有一个元素s[2^(k - 1)] = c[2^(k - 1)]


剩余层数迭代过程

先保证第一层：序号全部为奇数的放这层（这里序号从1开始）
这一层存储s[i] = a[i]

然后自顶向下生成每一层元素
k - 1层：第一个元素为s[2^(k-2)],生成元素间隔为2^(k-1)，边界是小于等于N的最大偶数

这一层存储
s[2^(k-2)] = c[2^(k-2)]
s[i] = c[i] - c[i - 2^(k-2)] (从第二个元素开始)

k - 2层：同理

```